import _ from 'lodash';
import * as vscode from 'vscode';

export class JenkinsHoverProvider implements vscode.HoverProvider {

    provideHover(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): vscode.ProviderResult<vscode.Hover> {
        const wordRange = document.getWordRangeAtPosition(position);
        if (!wordRange) {
            return;
        }

        const word = document.getText(wordRange);
        const hoverInfo: { [key: string]: KeywordInfo } = {
            'pipeline': {
                content: this.makePipeline(),
                description: '',
            },
            'node': {
                content: 'A node is a machine which is part of the Jenkins environment and is capable of executing a Pipeline.\n',
                description: '',
            },
            'tools': {
                content: this.makeTools(),
                description: '',
            },
            'options': {
                content: this.makeOptions(),
                description: '',
            },
            'disableConcurrentBuilds': {
                content: this.makeDisableConcurrentBuilds(),
                description: '',
            },
            'quietPeriod': {
                content: this.makeQuietPeriod(),
                description: '',
            },
            'retry': {
                content: this.makeRetry(),
                description: '',
            },
            'timeout': {
                content: this.makeTimeout(),
                description: '',
            },
            'buildDiscarder': {
                content: this.makeBuildDiscarder(),
                description: '',
            },
            'timestamps': {
                content: this.makeTimestamps(),
                description: '',
            },
            'environment': {
                content: this.makeEnvironment(),
                description: '',
            },
            'parameters': {
                content: this.makeParameter(),
                description: '',
            },
            'string': {
                content: this.makeString(),
                description: '',
            },
            'booleanParam': {
                content: this.makeBoolean(),
                description: '',
            },
            'choice': {
                content: this.makeChoice(),
                description: '',
            },
            'text': {
                content: this.makeText(),
                description: '',
            },
            'password': {
                content: this.makePassword(),
                description: '',
            },
            'triggers': {
                content: this.makeTriggers(),
                description: '',
            },
            'cron': {
                content: this.makeCron(),
                description: '',
            },
            'pollScm': {
                content: this.makePollScm(),
                description: '',
            },
            'upstream': {
                content: this.makeUpstream(),
                description: '',
            },
            'stages': {
                content: this.makeStages(),
                description: '',
            },
            'stage': {
                content: this.makeStage(),
                description: '',
            },
            'steps': {
                content: this.makeSteps(),
                description: '',
            },
            'script': {
                content: this.makeScript(),
                description: '',
            },
            'when': {
                content: this.makeWhen(),
                description: '',
            },
            'post': {
                content: this.makePost(),
                description: '',
            },
            'agent': {
                content: this.makeAgent(),
                description: '',
            },
            'docker': {
                content: this.makeDocker(),
                description: '',
            },
            'kubernetes': {
                content: this.makeKubernetes(),
                description: '',
            },
        };

        const keywordInfo = hoverInfo[word];
        if (keywordInfo) {
            const hoverContents = new vscode.MarkdownString(keywordInfo.content);
            return new vscode.Hover(hoverContents, wordRange);
        }

        return null;
    }

    makeTimestamps(): string {
        return `Options: \n
---
* timestamps: Prepend all console output generated by the Pipeline run with the time at which the line was emitted. For example: options { timestamps() }
---
### Usage:
\`\`\`groovy
options {
    timestamps()
}
\`\`\`
---`;
    }

    makeRetry(): string {
        return `Options: \n
---
* retry: On failure, retry the entire Pipeline the specified number of times. For example: options { retry(3) }
---
### Usage:
\`\`\`groovy
options {
    retry(3)
}
\`\`\`
---`;
    }

    makeQuietPeriod(): string {
        return `Options: \n
---
* quietPeriod: Set the quiet period, in seconds, for the Pipeline, overriding the global default. For example: options { quietPeriod(30) }
---
### Usage:
\`\`\`groovy
options {
    quietPeriod(30)
}
\`\`\`
---`;
    }

    makeDisableConcurrentBuilds(): string {
        return `Options: \n
---
* disableConcurrentBuilds: Disallow concurrent executions of the Pipeline. Can be useful for preventing simultaneous accesses to shared resources, etc.
For example: options { disableConcurrentBuilds() } to queue a build when there’s already an executing build of the Pipeline,
or options { disableConcurrentBuilds(abortPrevious: true) } to abort the running one and start the new build.
---
### Usage:
\`\`\`groovy
options {
    disableConcurrentBuilds()
}
\`\`\`
---`;
    }

    makeBuildDiscarder(): string {
        return `Options: \n
---
* buildDiscarder: Persist artifacts and console output for the specific number of recent Pipeline runs. For example: options { buildDiscarder(logRotator(numToKeepStr: '1')) }
---
### Usage:
\`\`\`groovy
options {
    buildDiscarder(logRotator(numToKeepStr: '__COUNT__'))
}
\`\`\`
---`;
    }

    makeTimeout(): string {
        return `Options: \n
---
* timeout: Set a timeout period for the Pipeline run, after which Jenkins should abort the Pipeline. For example: options { timeout(time: 1, unit: 'HOURS') }
---
### Usage:
\`\`\`groovy
options {
    timeout(time: __NUMBER__, unit: 'MINUTES')
}
\`\`\`
---`;
    }

    makeKubernetes(): string {
        return `Kubernetes: \n
---
Execute the Pipeline, or stage, inside a pod deployed on a Kubernetes cluster.
In order to use this option, the Jenkinsfile must be loaded from either a Multibranch Pipeline or a Pipeline from SCM.
The Pod template is defined inside the kubernetes { } block
---
### Usage:
\`\`\`groovy
    kubernetes {
        defaultContainer 'kaniko'
        yaml '''
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    imagePullPolicy: Always
    command:
    - sleep
    args:
    - 99d
    volumeMounts:
      - name: aws-secret
        mountPath: /root/.aws/
      - name: docker-registry-config
        mountPath: /kaniko/.docker
  volumes:
    - name: aws-secret
      secret:
        secretName: aws-secret
    - name: docker-registry-config
      configMap:
        name: docker-registry-config
'''
   }
\`\`\`
---`;
    }

    makeDocker(): string {
        return `Docker: \n
---
Execute the Pipeline, or stage, with the given container which will be dynamically provisioned on a node pre-configured to accept Docker-based Pipelines,
or on a node matching the optionally defined label parameter.
docker also optionally accepts an args parameter which may contain arguments to pass directly to a docker run invocation,
and an alwaysPull option, which will force a docker pull even if the image name is already present
---
### Usage:
\`\`\`groovy
docker {
    image 'maven:3.9.3-eclipse-temurin-17'
    label 'my-defined-label'
    args  '-v /tmp:/tmp'
}
\`\`\`
---`;
    }

    makeAgent(): string {
        return `Agent: \n
---
The agent section specifies where the entire Pipeline, or a specific stage, will execute in the Jenkins environment depending on where the agent section is placed.
The section must be defined at the top-level inside the pipeline block, but stage-level usage is optional.
---
### Usage:
\`\`\`groovy
agent any
\`\`\`
---`;
    }

    makePost(): string {
        return `Post: \n
---
The post section defines one or more additional steps that are run upon the completion of a Pipeline's or stage's run (depending on the location of the post section within the Pipeline).
post can support any of the following post-condition blocks: always, changed, fixed, regression, aborted, failure, success, unstable, unsuccessful, and cleanup.
These condition blocks allow the execution of steps inside each condition depending on the completion status of the Pipeline or stage
---
### Usage:
\`\`\`groovy
post {
    success {
        script {
        }
    }
    failure {
        script {
        }
    }
}
\`\`\`
---
### Conditions:
---
* always: Run the steps in the post section regardless of the completion status of the Pipeline's or stage's run.
* changed: Only run the steps in post if the current Pipeline's run has a different completion status from its previous run.
* fixed: Only run the steps in post if the current Pipeline's run is successful and the previous run failed or was unstable.
* regression: Only run the steps in post if the current Pipeline's or status is failure, unstable, or aborted and the previous run was successful.
* aborted: Only run the steps in post if the current Pipeline's run has an "aborted" status, usually due to the Pipeline being manually aborted. This is typically denoted by gray in the web UI.
* failure: Only run the steps in post if the current Pipeline's or stage's run has a "failed" status, typically denoted by red in the web UI.
* success: Only run the steps in post if the current Pipeline's or stage's run has a "success" status, typically denoted by blue or green in the web UI.
* unstable: Only run the steps in post if the current Pipeline's run has an "unstable" status, usually caused by test failures, code violations, etc. This is typically denoted by yellow in the web UI.
* unsuccessful: Only run the steps in post if the current Pipeline's or stage's run has not a "success" status. This is typically denoted in the web UI depending on the status previously mentioned (for stages this may fire if the build itself is unstable).
* cleanup: Run the steps in this post condition after every other post condition has been evaluated, regardless of the Pipeline or stage's status
---
### snippet:
---
* post: make post`;
    }

    makeWhen(): string {
        return `When: \n
---
The when directive allows the Pipeline to determine whether the stage should be executed depending on the given condition.
The when directive must contain at least one condition. If the when directive contains more than one condition, all the child conditions must return true for the stage to execute.
This is the same as if the child conditions were nested in an allOf condition (refer to the examples below).
If an anyOf condition is used, note that the condition skips remaining tests as soon as the first "true" condition is found.
---
### Usage:
\`\`\`groovy
when {
    expression { params.__NAME__ == 'yes' }
}
\`\`\`
---
* __NAME__: Parameter Name
---
### snippet:
---
* when: make when expression`;
    }

    makeScript(): string {
        return `Script: \n
---
The script step takes a block of Scripted Pipeline and executes that in the Declarative Pipeline.
For most use-cases, the script step should be unnecessary in Declarative Pipelines, but it can provide a useful "escape hatch".
script blocks of non-trivial size and/or complexity should be moved into Shared Libraries instead.
---
### Usage:
\`\`\`groovy
script {
    def browsers = ['chrome', 'firefox']
    for (int i = 0; i < browsers.size(); ++i) {
        echo "Testing the $\{browsers[i]} browser"
    }
}
\`\`\`
---`;
    }

    makeSteps(): string {
        return `Steps: \n
---
A stage block defines a conceptually distinct subset of tasks performed through the entire Pipeline(e.g. "Build", "Test" and "Deploy" stages),
which is used by many plugins to visualize or present Jenkins Pipeline status / progress.
---
### Usage:
\`\`\`groovy
steps {
    sh """
        echo Hello
    """
}
\`\`\`
---
`;
    }

    makeStage(): string {
        return `Stages: \n
---
### Usage:
\`\`\`groovy
stage('__STAGE_NAME__') {
    steps {
        sh "echo Hello"
    }
}
\`\`\`
---
* __STAGE_NAME__: stage name
---
### snippet:
---
* sta, stg: make stage
---`;
    }

    makeStages(): string {
        return `Stages: \n
---
Containing a sequence of one or more stage directives, the stages section is where the bulk of the "work" described by a Pipeline will be located. At a minimum, it is recommended that stages contain at least one stage directive for each discrete part of the continuous delivery process, such as Build, Test, and Deploy
---
### Usage:
\`\`\`groovy
stages {
    stage('__STAGE_NAME__') {
        steps {
            sh "echo Hello"
        }
    }
}
\`\`\`
---
* __STAGE_NAME__: stage name
---`;
    }

    makeOptions(): string {
        return `Options: \n
---
The options directive allows configuring Pipeline-specific options from within the Pipeline itself.
Pipeline provides a number of these options, such as buildDiscarder, but they may also be provided by plugins, such as timestamps
---
### Usage:
\`\`\`groovy
options {
    timeout(time: __NUMBER__, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '__COUNT__'))
}
\`\`\`
---
Available Options
---
* buildDiscarder: Persist artifacts and console output for the specific number of recent Pipeline runs. For example: options { buildDiscarder(logRotator(numToKeepStr: '1')) }
* checkoutToSubdirectory: Perform the automatic source control checkout in a subdirectory of the workspace. For example: options { checkoutToSubdirectory('foo') }
* disableConcurrentBuilds: Disallow concurrent executions of the Pipeline. Can be useful for preventing simultaneous accesses to shared resources, etc. For example: options { disableConcurrentBuilds() } to queue a build when there’s already an executing build of the Pipeline, or options { disableConcurrentBuilds(abortPrevious: true) } to abort the running one and start the new build.
* disableResume: Do not allow the pipeline to resume if the controller restarts. For example: options { disableResume() }
* newContainerPerStage: Used with docker or dockerfile top-level agent. When specified, each stage will run in a new container instance on the same node, rather than all stages running in the same container instance.
* overrideIndexTriggers: Allows overriding default treatment of branch indexing triggers. If branch indexing triggers are disabled at the multibranch or organization label, options { overrideIndexTriggers(true) } will enable them for this job only. Otherwise, options { overrideIndexTriggers(false) } will disable branch indexing triggers for this job only.
* preserveStashes: Preserve stashes from completed builds, for use with stage restarting. For example: options { preserveStashes() } to preserve the stashes from the most recent completed build, or options { preserveStashes(buildCount: 5) } to preserve the stashes from the five most recent completed builds.
* quietPeriod: Set the quiet period, in seconds, for the Pipeline, overriding the global default. For example: options { quietPeriod(30) }
* retry: On failure, retry the entire Pipeline the specified number of times. For example: options { retry(3) }
* skipDefaultCheckout: Skip checking out code from source control by default in the agent directive. For example: options { skipDefaultCheckout() }
* skipStagesAfterUnstable: Skip stages once the build status has gone to UNSTABLE. For example: options { skipStagesAfterUnstable() }
* timeout: Set a timeout period for the Pipeline run, after which Jenkins should abort the Pipeline. For example: options { timeout(time: 1, unit: 'HOURS') }
---
### snippet:
---
* opt: make options`;
    }

    makeEnvironment(): string {
        return `Environment:\n
---
The environment directive specifies a sequence of key-value pairs which will be defined as environment variables for all steps,
or stage-specific steps, depending on where the environment directive is located within the Pipeline.
---
### Usage:
\`\`\`groovy
environment {
    // **KEY=VALUE**
    VERSION='0.0.1-SNAPSHOT'
}
\`\`\`
---

* _KEY_: key
* _VALUE_: value
---
### snippet:
---
* env: make Environment`;
    }

    makeUpstream(): string {
        return `Triggers: \n
---
* upstream: Accepts a comma-separated string of jobs and a threshold. When any job in the string finishes with the minimum threshold, the Pipeline will be re-triggered. For example: triggers { upstream(upstreamProjects: 'job1,job2', threshold: hudson.model.Result.SUCCESS) }
---
### Usage:
\`\`\`groovy
triggers {
    upstream(upstreamProjects: 'job1,job2', threshold: hudson.model.Result.SUCCESS)
}
\`\`\`
---
`;
    }

    makePollScm(): string {
        return `Triggers: \n
---
* pollSCM: Accepts a cron-style string to define a regular interval at which Jenkins should check for new source changes. If new changes exist, the Pipeline will be re-triggered. For example: triggers { pollSCM('H /4* * 1-5') }
---
### Usage:
\`\`\`groovy
triggers {
    pollSCM('H /4* * 1-5')
}
\`\`\`
---
`;
    }

    makeCron(): string {
        return `Triggers: \n
---
* cron: Accepts a cron-style string to define a regular interval at which the Pipeline should be re-triggered, for example: triggers { cron('H */4* * 1-5') }.
---
### Usage:
\`\`\`groovy
triggers {
    cron('H */4 * * 1-5')
}
\`\`\`
---
`;
    }

    makeTriggers(): string {
        return `Triggers: \n
---
The triggers directive defines the automated ways in which the Pipeline should be re-triggered.
For Pipelines which are integrated with a source such as GitHub or BitBucket, triggers may not be necessary as webhooks-based integration will likely already be present.
The triggers currently available are cron, pollSCM and upstream.
---
### Usage:
\`\`\`groovy
triggers {
    cron('H */4 * * 1-5')
}
\`\`\`
---
* cron: Accepts a cron-style string to define a regular interval at which the Pipeline should be re-triggered, for example: triggers { cron('H */4* * 1-5') }.
* pollSCM: Accepts a cron-style string to define a regular interval at which Jenkins should check for new source changes. If new changes exist, the Pipeline will be re-triggered. For example: triggers { pollSCM('H /4* * 1-5') }
* upstream: Accepts a comma-separated string of jobs and a threshold. When any job in the string finishes with the minimum threshold, the Pipeline will be re-triggered. For example: triggers { upstreamupstreamProjects: 'job1,job2', threshold: hudson.model.Result.SUCCESS) }
---
`;
    }

    makeChoice(): string {
        return `Parameters:\n
---
* choice: A choice parameter, for example: parameters { choice(name: 'CHOICES', choices: ['one', 'two', 'three'], description: '') }. The first value is the default.
---
### Usage:
\`\`\`groovy
parameters {
    choice(name: 'CHOICE', choices: ['One', 'Two', 'Three'], description: 'Pick something')
}
\`\`\`
---`;
    }

    makeString(): string {
        return `Parameters:\n
---
* string: A parameter of a string type, for example: parameters { string(name: 'DEPLOY_ENV', defaultValue: 'staging', description: '') }.
---
### Usage:
\`\`\`groovy
parameters {
    string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?')
}
\`\`\`
---`;
    }

    makeText(): string {
        return `Parameters:\n
---
* text: A text parameter, which can contain multiple lines, for example: parameters { text(name: 'DEPLOY_TEXT', defaultValue: 'One\nTwo\nThree\n', description: '') }.
---
### Usage:
\`\`\`groovy
parameters {
    text(name: 'BIOGRAPHY', defaultValue: '', description: 'Enter some information about the person')
}
\`\`\`
---`;
    }

    makeBoolean(): string {
        return `Parameters:\n
---
* booleanParam: A boolean parameter, for example: parameters { booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '') }.
---
### Usage:
\`\`\`groovy
parameters {
    booleanParam(name: 'TOGGLE', defaultValue: true, description: 'Toggle this value')
}
\`\`\`
---`;
    }

    makePassword(): string {
        return `Parameters:\n
---
* password: A password parameter, for example: parameters { password(name: 'PASSWORD', defaultValue: 'SECRET', description: 'A secret password') }.
---
### Usage:
\`\`\`groovy
parameters {
    password(name: 'PASSWORD', defaultValue: 'SECRET', description: 'Enter a password')
}
\`\`\`
---`;
    }

    makeParameter(): string {
        return `Parameters:\n
---
The parameters directive provides a list of parameters that a user should provide when triggering the Pipeline.
The values for these user-specified parameters are made available to Pipeline steps via the params object, refer to the Parameters,
Declarative Pipeline for its specific usage
---
### Usage:
\`\`\`groovy
parameters {
    string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?')
    text(name: 'BIOGRAPHY', defaultValue: '', description: 'Enter some information about the person')
    booleanParam(name: 'TOGGLE', defaultValue: true, description: 'Toggle this value')
    choice(name: 'CHOICE', choices: ['One', 'Two', 'Three'], description: 'Pick something')
    password(name: 'PASSWORD', defaultValue: 'SECRET', description: 'Enter a password')
}
\`\`\`
---
Available Parameters
---
* string: A parameter of a string type, for example: parameters { string(name: 'DEPLOY_ENV', defaultValue: 'staging', description: '') }.
* text: A text parameter, which can contain multiple lines, for example: parameters { text(name: 'DEPLOY_TEXT', defaultValue: 'One\nTwo\nThree\n', description: '') }.
* booleanParam: A boolean parameter, for example: parameters { booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '') }.
* choice: A choice parameter, for example: parameters { choice(name: 'CHOICES', choices: ['one', 'two', 'three'], description: '') }. The first value is the default.
* password: A password parameter, for example: parameters { password(name: 'PASSWORD', defaultValue: 'SECRET', description: 'A secret password') }.
---
### snippet:
---
* par: make Parameter
* past: make String
* pach: make Choices`;
    }

    makeTools(): string {
        return `Tools:\n
---
A section defining tools to auto-install and put on the PATH.
This is ignored if agent none is specified. \n
---
Supported Tools
---
* maven
* jdk
* gradle
---`;
    }

    makePipeline(): string {
        return `Pipeline: \n
---
A Pipeline is a user-defined model of a CD pipeline.
A Pipeline's code defines your entire build process, which typically includes stages for building an application, testing it and then delivering it.
---
Pipeline Syntax \n
---
* https://{YOUR_JENKINS}/jenkins/pipeline-syntax/
* https://www.jenkins.io/doc/book/pipeline/syntax/
---
`;
    }

}

interface KeywordInfo {
    content: string;
    description: string;
}
